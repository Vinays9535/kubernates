
                                                                                                  1). namespace object creation

* Shows all namespaces currently in the cluster:
  kubectl get namespaces

* This creates a new namespace named amma
  kubectl create namespace amma

* View namespace details ,Shows labels, annotations, resource quotas, and status of the namespace.
  kubectl describe namespace amma

                                                                                    (first create a custom name space after we set deafult namespace)

* Check current context namespace, show default name space
  kubectl config view --minify | grep namespace:

* Set new default namespace
  kubectl config set-context --current --namespace=amma

* Check current context namespace, show default name space
  kubectl config view --minify | grep namespace:

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


                                                                                                    2). Create secret object 
                                                                                                     
* Create secret object command
  kubectl create secret docker-registry my-docker-secret \
  --docker-server=https://index.docker.io/v1/ \
  --docker-username=vinaykumars064 \
  --docker-password=vini9535@ \
  --docker-email=vinaykumars064@gmail.com


* ðŸ”¹ Explanation:

--my-docker-secret â†’ Secret name.

--docker-server â†’ Registry URL (https://index.docker.io/v1/ for Docker Hub).

--docker-username â†’ Your Docker Hub username.

--docker-password â†’ Your Docker Hub password / access token.

--docker-email â†’ Your email. 


*  kubectl get secrets  or  kubectl get svc
*  kubectl describe secret my-docker-secret


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

                                                                                                   
                                                                                              3). pod object creation with secret and container port

Uses a Secret for private Docker registry login

Runs a container with an exposed container port    

* first create one file cold pod.yaml
  touch pod.yaml
  vim pod.yaml
  cat pod.yaml
  

example:::

   apiVersion: v1
kind: Pod
metadata:
  name: my-pod
  labels:
    app: my-pod
spec:
  containers:
  - name: my-pod
    image: vinaykumars064/cicd-repo:latest                # private image
    ports:
    - containerPort: 80                            # container port exposed
  imagePullSecrets:
  - name: my-docker-secret                         # secret created earlier



  Steps to Use ::

  *  Apply the Pod
     kubectl apply -f pod.yaml

  *  Verify pod status
     kubectl get pods
     kubectl describe pod my-pod




  âœ… What happens here?

      Kubernetes uses my-docker-secret to log in to Docker Hub (or your registry).

      The Pod pulls private-nginx:latest.

      The container exposes port 80 internally (you can later attach a Service to make it accessible). 

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------      

      
                                                                                          4). deployment object creation with secret and container port



Hereâ€™s a ready-to-use deployment.yaml that creates a Deployment in Kubernetes with:

Secret for pulling a private Docker image

Container port exposed


* first create one file cold deployment.yaml
  touch deployment.yaml
  vim deployment.yaml
  cat deployment.yaml
  

example:::



apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app-deployment
  labels:
    app: my-app
spec:
  replicas: 2                                # number of Pods to run
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
      - name: my-app-container
        image: your-docker-user/your-private-image:latest   # replace with your private image
        ports:
        - containerPort: 8080                               # expose port inside container
      imagePullSecrets:
      - name: my-docker-secret                              # secret created earlier




1. Apply the Deployment
kubectl apply -f deployment.yaml

2. Verify
kubectl get deployments
kubectl get pods
kubectl describe deployment my-app-deployment


âœ… Explanation

replicas: 2 â†’ runs 2 Pods for scaling.

containerPort: 8080 â†’ container listens on port 8080.

imagePullSecrets â†’ allows Kubernetes to use the secret when pulling from a private Docker registry.


-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


                                                                                                 5). service object 

                                                                                                    A) cluster ip 


create a deployment object with docker secrets and service ( cluster ip ) and port number with 2 replicas

touch deployment.ymal : create one file
vim deployment.yaml : copy and paste


apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-deployment
  labels:
    app: my-deployment
spec:
  replicas: 2
  selector:
    matchLabels:
      app: my-deployment
  template:
    metadata:
      labels:
        app: my-deployment
    spec:
      containers:
      - name: my-deployment
        image: vinaykumars064/cicd-repo:latest   # replace with your private image
        ports:
        - containerPort: 8080
      imagePullSecrets:
      - name: my-docker-secret

---
apiVersion: v1
kind: Service
metadata:
  name: my-service
  labels:
    app: my-service
spec:
  type: ClusterIP
  selector:
    app: my-service
  ports:
  - port: 8080        # Service port (internal)
    targetPort: 8080  # Container port


* cat deployment.yaml : describe


Apply YAML
* kubectl apply -f deployment.yaml

Verify Service
* kubectl get svc my-app-service


You should see something like:

NAME             TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)    AGE
my-app-service   ClusterIP   10.96.123.45   <none>        8080/TCP   10s


This means your pods are internally reachable within the cluster at http://my-app-service:8080


this deployment and service internally working or not 
using this command to login the conatainer
* kubectl exec -it <full conatainer name > -- /bin/bash




then check : 

How to correctly test?

âœ… From inside the cluster (a Pod):

kubectl exec -it <your-pod-name> -- curl http://172.20.85.52:8080


âœ… From a Service (ClusterIP):
If you already created a ClusterIP service for your deployment:

* kubectl get svc


Example output:

NAME            TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE
my-app-service  ClusterIP   10.100.200.15   <none>        80/TCP    10m


You can test it inside a pod:

kubectl exec -it <your-pod-name> -- curl http://my-app-service:80





if you not install the curl you will install the curl 
Install curl inside your running pod

If your container has a package manager (apt, apk, yum), you can install curl inside:

apt update && apt install -y curl

Then:

curl http://172.20.85.52:8080

                                                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
